<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8">
<title>像素打磚塊 · 3關 · 生動拖尾 · 10倍隕石（球清空才死 / 過關重啟球）</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#000;}
#container{position:fixed;left:50%;top:50%;transform-origin:center;}
canvas{display:block;background:#000;image-rendering:pixelated;}
</style>
</head>
<body>
<div id="container"><canvas id="game"></canvas></div>

<script>
(()=>{
/* ===== 畫布 ===== */
const cvs=document.getElementById("game"),ctx=cvs.getContext("2d");
const W=540,H=960; cvs.width=W; cvs.height=H;
function layout(){
  const s=Math.min(innerWidth/H,innerHeight/W);
  document.getElementById("container").style.transform=
    `translate(-50%,-50%) rotate(90deg) scale(${s})`;
}
addEventListener("resize",layout);layout();

/* ===== 關卡 ===== */
let level=1;
const MAX_LEVEL=3;
const LEVEL_ROWS={1:7,2:9,3:11};

/* ===== 狀態 ===== */
const paddle={baseW:160,w:160,h:20,x:(W-160)/2,y:H-80,enlargeUntil:0,enlargePhase:0};
let balls=[],bricks=[],particles=[],trail=[],flashes=[];
let state="transition"; // play | transition | win | fail
const shake={t:0,amp:0};

/* ===== 工具 ===== */
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
const now=()=>performance.now();
function normalize(b){
  const s=Math.hypot(b.vx,b.vy)||1, f=b.speed/s;
  b.vx*=f; b.vy*=f;
}
function reflect(b,nx,ny){
  const d=b.vx*nx+b.vy*ny;
  b.vx-=2*d*nx; b.vy-=2*d*ny;
  normalize(b);
}
function circleRectHit(b,rx,ry,rw,rh){
  const R=(now()<b.meteorUntil)?100:10;
  const nx=clamp(b.x,rx,rx+rw);
  const ny=clamp(b.y,ry,ry+rh);
  const dx=b.x-nx,dy=b.y-ny;
  return dx*dx+dy*dy<=R*R;
}
function burst(x,y,c,n=18){
  for(let i=0;i<n;i++){
    const a=Math.random()*Math.PI*2, sp=0.8+Math.random()*2.2;
    particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:28,c,size:2+Math.random()*2});
  }
}
function meteorSparks(x,y){
  for(let i=0;i<4;i++){
    const a=Math.random()*Math.PI*2;
    const sp=0.6+Math.random()*1.8;
    particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:20,c:"#ff9b50",size:2+Math.random()*2});
  }
}
function flash(){ flashes.push({life:12}); }
function addShake(intensity=6, duration=180){
  shake.amp=Math.max(shake.amp,intensity);
  shake.t=Math.max(shake.t,duration);
}

/* ===== 特殊磚 ===== */
function enlarge(){
  paddle.w=paddle.baseW*1.9;
  paddle.enlargeUntil=now()+5000;
  paddle.enlargePhase=1;
  flash(); burst(paddle.x+paddle.w/2,paddle.y-8,"#39e071",26);
  addShake(4,120);
}
function multiball(b){
  const base=Math.atan2(b.vy,b.vx);
  [-18,18].forEach(d=>{
    const A=base+d*Math.PI/180;
    balls.push({
      x:b.x,y:b.y,r:10,
      vx:Math.cos(A)*b.speed,vy:Math.sin(A)*b.speed,
      speed:b.speed,launched:true,meteorUntil:0
    });
  });
  // 原球變隕石（10倍、慢一點更重）
  b.meteorUntil=now()+5000;
  b.speed=2.6;
  normalize(b);
  burst(b.x,b.y,"#ff8844",38);
  flash(); addShake(9,240);
}

/* ===== 建磚（掉落） ===== */
function makeBricks(lv){
  bricks=[];
  const cols=8,rows=LEVEL_ROWS[lv];
  const mx=25,my=100,bw=(W-mx*2)/cols,bh=40;
  const pal=["#ff4b4b","#ffa14b","#ffea4b","#4bff80","#4bcaff","#b64bff"];

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      let type="normal",color=pal[(r+c)%pal.length];
      const roll=Math.random();
      if(roll<.08){type="enlarge";color="#39e071";}
      else if(roll<.16){type="multiball";color="#b64bff";}

      const ty=my+r*bh;
      bricks.push({
        x:mx+c*bw,
        y:ty-650-Math.random()*240,
        ty,vy:6.2,
        w:bw-4,h:bh-4,
        type,color,alive:true,falling:true
      });
    }
  }
}

/* ===== 球初始化（重啟球用） ===== */
function initBall(){
  balls=[{
    x:W/2,y:H-120,r:10,
    vx:0,vy:0,
    speed:3.2,
    launched:false,
    meteorUntil:0
  }];
}

/* ===== 重啟球（給過關用） ===== */
function restartBallsForNextLevel(){
  initBall();
  // 拖尾清掉比較乾淨（你想保留也可以把這行刪掉）
  trail.length=0;
}

/* ===== 控制 ===== */
addEventListener("mousemove",e=>{
  const rect=cvs.getBoundingClientRect();
  const mx=e.clientY-rect.top;
  paddle.x=clamp(mx-paddle.w/2,0,W-paddle.w);
  for(const b of balls){
    if(!b.launched){
      b.x=paddle.x+paddle.w/2;
      b.y=paddle.y-b.r-2;
    }
  }
});
addEventListener("keydown",e=>{
  if(e.code==="Space"){
    if(state==="fail" || state==="win"){
      resetGame();
      return;
    }
    if(state!=="play") return;

    const b=balls.find(v=>!v.launched);
    if(b){
      b.launched=true;
      const a=(-58+Math.random()*26)*Math.PI/180;
      b.vx=Math.cos(a)*b.speed;
      b.vy=-Math.abs(Math.sin(a))*b.speed;
    }
  }
});

/* ===== 轉場（磚塊落下） ===== */
function updateTransition(){
  let done=true;
  for(const br of bricks){
    if(!br.alive) continue;
    if(!br.falling) continue;
    br.y+=br.vy;
    br.vy+=0.45;
    if(br.y>=br.ty){
      br.y=br.ty;
      br.vy=0;
      br.falling=false;
    }else done=false;
  }
  if(done){
    state="play";
    // 確保至少有一顆待命球（正常情況過關已重啟了）
    if(!balls.length) restartBallsForNextLevel();
  }
}

/* ===== 更新 ===== */
function update(){
  const t=now();

  if(state==="fail" || state==="win") {
    // 失敗/勝利時也讓特效慢慢消退，畫面更爽
  } else {
    // 變大板到期
    if(paddle.enlargeUntil && t>paddle.enlargeUntil){
      paddle.w=paddle.baseW;
      paddle.enlargeUntil=0;
      paddle.enlargePhase=0;
    }

    if(state==="transition"){
      updateTransition();
    }else if(state==="play"){
      // 球更新
      for(let i=balls.length-1;i>=0;i--){
        const b=balls[i];
        if(!b.launched) continue;

        const isMeteor = t<b.meteorUntil;
        const R = isMeteor ? 100 : b.r;

        b.x+=b.vx; b.y+=b.vy;

        // 拖尾
        trail.push({x:b.x,y:b.y,life:isMeteor?34:22,meteor:isMeteor});
        if(trail.length>420) trail.shift();
        if(isMeteor) meteorSparks(b.x - b.vx*0.8, b.y - b.vy*0.8);

        // 牆
        if(b.x-R<=0){ b.x=R; reflect(b,1,0); }
        if(b.x+R>=W){ b.x=W-R; reflect(b,-1,0); }
        if(b.y-R<=0){ b.y=R; reflect(b,0,1); }

        // 擋板
        if(b.y+R>=paddle.y && b.x>=paddle.x && b.x<=paddle.x+paddle.w && b.vy>0){
          b.y=paddle.y-R;
          reflect(b,0,-1);
          if(isMeteor) addShake(6,160);
        }

        // 磚塊（一次只處理一顆）
        for(const br of bricks){
          if(!br.alive) continue;
          if(circleRectHit(b,br.x,br.y,br.w,br.h)){
            br.alive=false;
            burst(br.x+br.w/2, br.y+br.h/2, br.color, isMeteor?28:18);
            if(br.type==="enlarge") enlarge();
            else if(br.type==="multiball") multiball(b);

            reflect(b,0,1);
            flash();
            addShake(isMeteor?10:4, isMeteor?240:140);
            break;
          }
        }

        // 掉到底：移除該球（不立刻 Game Over）
        if(b.y - R > H){
          balls.splice(i,1);
        }
      }

      // ⭐ 過關優先：磚塊清空 → 跳關 + 重啟球
      if(!bricks.some(b=>b.alive)){
        if(level<MAX_LEVEL){
          level++;
          state="transition";
          makeBricks(level);
          restartBallsForNextLevel();   // ✅ 你要的：跳關球要重啟
          flash(); addShake(7,240);
        }else{
          state="win";
          flash(); addShake(12,320);
        }
      }

      // ⭐ 你要的：場上都沒有球 → Game Over
      if(state==="play" && balls.length===0){
        state="fail";
        flash(); addShake(10,260);
      }
    }
  }

  // 粒子/拖尾/閃白/震動更新（fail/win 也更新，畫面更活）
  for(const p of particles){ p.x+=p.vx; p.y+=p.vy; p.vy+=.14; p.life--; }
  particles=particles.filter(p=>p.life>0);

  for(const tr of trail) tr.life--;
  trail=trail.filter(tr=>tr.life>0);

  for(const f of flashes) f.life--;
  flashes=flashes.filter(f=>f.life>0);

  if(shake.t>0){
    shake.t-=16;
    shake.amp*=0.92;
    if(shake.t<=0){shake.t=0; shake.amp=0;}
  }
}

/* ===== 繪製 ===== */
function draw(){
  const dx = (shake.t>0? (Math.random()*2-1)*shake.amp : 0);
  const dy = (shake.t>0? (Math.random()*2-1)*shake.amp : 0);

  ctx.save();
  ctx.translate(dx,dy);

  // 背景像素格
  ctx.fillStyle="#0a0a1a"; ctx.fillRect(0,0,W,H);
  for(let y=0;y<H;y+=28){
    for(let x=0;x<W;x+=28){
      ctx.fillStyle=(x+y)%56===0?"#111a33":"#0d132a";
      ctx.fillRect(x,y,28,28);
    }
  }

  // 磚
  for(const br of bricks){
    if(!br.alive) continue;
    ctx.fillStyle=br.color; ctx.fillRect(br.x,br.y,br.w,br.h);
    ctx.fillStyle="#000"; ctx.fillRect(br.x,br.y+br.h-3,br.w,3);
  }

  // 底板
  if(paddle.enlargePhase){
    const k=(Math.sin(now()/90)*0.5+0.5);
    ctx.shadowBlur=26+12*k;
    ctx.shadowColor="#39e071";
    ctx.fillStyle=`rgba(57,224,113,${0.45+0.35*k})`;
  }else ctx.fillStyle="#d8d8d8";
  ctx.fillRect(paddle.x,paddle.y,paddle.w,paddle.h);
  ctx.shadowBlur=0;

  // 拖尾
  for(const tr of trail){
    const a = tr.life/(tr.meteor?34:22);
    ctx.globalAlpha = a*0.65;
    ctx.fillStyle = tr.meteor ? "#ff9b50" : "#99d6ff";
    ctx.beginPath();
    ctx.arc(tr.x,tr.y, tr.meteor ? (10 + 8*a) : (3 + 3*a), 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha=1;

  // 球
  for(const b of balls){
    const isMeteor = now()<b.meteorUntil;
    if(isMeteor){
      const R=100;
      const g=ctx.createRadialGradient(b.x,b.y,R*0.2,b.x,b.y,R);
      g.addColorStop(0,"rgba(255,235,200,0.90)");
      g.addColorStop(0.6,"rgba(255,155,80,0.55)");
      g.addColorStop(1,"rgba(255,120,40,0.25)");
      ctx.fillStyle=g;
      ctx.beginPath(); ctx.arc(b.x,b.y,R,0,Math.PI*2); ctx.fill();
      ctx.shadowBlur=22; ctx.shadowColor="#ffb066";
      ctx.strokeStyle="rgba(255,200,120,0.85)"; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(b.x,b.y,R-2,0,Math.PI*2); ctx.stroke();
      ctx.shadowBlur=0;
    }else{
      ctx.fillStyle="#fff";
      ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
    }
  }

  // 粒子
  for(const p of particles){
    ctx.globalAlpha = Math.max(p.life/28,0);
    ctx.fillStyle = p.c;
    ctx.fillRect(p.x,p.y,p.size,p.size);
  }
  ctx.globalAlpha=1;

  // HUD
  ctx.fillStyle="rgba(255,255,255,0.85)";
  ctx.font="bold 22px monospace";
  ctx.textAlign="left";
  ctx.fillText(`LEVEL ${level}/3`, 16, 34);

  // 狀態字
  if(state==="transition"){
    ctx.textAlign="center";
    ctx.font="bold 44px monospace";
    ctx.fillStyle="#fff";
    ctx.fillText(`LEVEL ${level}`, W/2, H/2);
  }
  if(state==="fail"){
    ctx.textAlign="center";
    ctx.font="bold 56px monospace";
    ctx.fillStyle="#fff";
    ctx.fillText("GAME OVER", W/2, H/2);
    ctx.font="bold 20px monospace";
    ctx.fillText("Press Space to Restart", W/2, H/2+52);
  }
  if(state==="win"){
    ctx.textAlign="center";
    ctx.font="bold 56px monospace";
    ctx.fillStyle="#fff";
    ctx.fillText("YOU WIN", W/2, H/2);
    ctx.font="bold 20px monospace";
    ctx.fillText("Press Space to Restart", W/2, H/2+52);
  }

  // 閃白
  for(const f of flashes){
    ctx.globalAlpha = (f.life/12)*0.35;
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,W,H);
  }
  ctx.globalAlpha=1;

  // CRT
  ctx.globalAlpha=0.15; ctx.fillStyle="#000";
  for(let y=0;y<H;y+=3) ctx.fillRect(0,y,W,1);
  ctx.globalAlpha=1;
  const vign=ctx.createRadialGradient(W/2,H/2,0,W/2,H/2,W*0.8);
  vign.addColorStop(0,"rgba(0,0,0,0)");
  vign.addColorStop(1,"rgba(0,0,0,0.35)");
  ctx.fillStyle=vign; ctx.fillRect(0,0,W,H);

  ctx.restore();
}

/* ===== 重置 ===== */
function resetGame(){
  level=1;
  state="transition";
  particles=[]; trail=[]; flashes=[];
  paddle.w=paddle.baseW; paddle.enlargeUntil=0; paddle.enlargePhase=0;
  makeBricks(1);
  initBall();
  flash(); addShake(6,200);
}

/* ===== 啟動 ===== */
makeBricks(1);
initBall();
(function loop(){ update(); draw(); requestAnimationFrame(loop); })();
})();
</script>
</body>
</html>
