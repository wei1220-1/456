<!doctype html>
<html lang="zh-Hant">
<head>
<meta charset="utf-8">
<title>像素打磚塊 · 5關 · 不講武德爽爆版（手動發射版）</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
html,body{margin:0;height:100%;overflow:hidden;background:#000;}
#container{position:fixed;left:50%;top:50%;transform-origin:center;}
canvas{display:block;background:#000;image-rendering:pixelated;}
</style>
</head>
<body>
<div id="container"><canvas id="game"></canvas></div>

<script>
(()=>{
/* ===== Canvas ===== */
const cvs=document.getElementById("game"),ctx=cvs.getContext("2d");
const W=540,H=960; cvs.width=W; cvs.height=H;
function layout(){
  const s=Math.min(innerWidth/H,innerHeight/W);
  document.getElementById("container").style.transform=
    `translate(-50%,-50%) rotate(90deg) scale(${s})`;
}
addEventListener("resize",layout);layout();

/* ===== Tuning：爽感旋鈕 ===== */
const JUICE = {
  hitstopMax: 3,
  baseBallSpeed: 3.85,
  rageSpeedK: 1.10,
  comboDecayMs: 850,
  rageThreshold: 10,
  rageMs: 2600,
  laserSweepSpeed: 26,
  bombRadius: 120,
  bombChainRadius: 95,
  turretMs: 2200,
  turretCooldown: 55,
  turretSpreadDeg: 6,
  turretPelletsPerSide: 2
};

/* ===== Levels ===== */
let level=1;
const MAX_LEVEL=5;
const LEVEL_ROWS={1:7,2:9,3:11,4:12,5:13};
const COLS=8;

/* ===== State ===== */
const paddle={baseW:160,w:160,h:20,x:(W-160)/2,y:H-80,enlargeUntil:0,enlargePhase:0};
let balls=[], bricks=[], particles=[], trail=[], flashes=[];
let bullets=[], laserBeams=[], explosions=[];
let state="transition"; // play | transition | win | fail
const shake={t:0,amp:0};

/* ===== Juice: Combo/Rage/Hitstop ===== */
let combo=0, comboTimer=0, rageUntil=0;
let hitstop=0;

/* ===== Colors ===== */
const COLOR_ENLARGE="#39e071";
const COLOR_MULTIBALL="#b64bff";
const COLOR_TURRET="#4bcaff";
const COLOR_LASER="#fff07a";
const COLOR_BOMB="#ff5a3d";
const COLOR_UNBREAK="#2c2f35";
const HARD_COLOR_FULL="#9aa3ad";
const HARD_COLOR_DMG ="#c7d0da";

/* ===== Turret ===== */
let turretUntil=0;
let lastShotMs=0;

/* ===== Utils ===== */
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
const now=()=>performance.now();
const EPS=0.9;

function normalizeBall(b){
  const s=Math.hypot(b.vx,b.vy)||1, f=b.speed/s;
  b.vx*=f; b.vy*=f;
}
function reflect(b,nx,ny){
  const d=b.vx*nx+b.vy*ny;
  b.vx-=2*d*nx; b.vy-=2*d*ny;
  normalizeBall(b);
}
function resolveCircleRect(b, R, rx, ry, rw, rh){
  const cx = clamp(b.x, rx, rx+rw);
  const cy = clamp(b.y, ry, ry+rh);
  let dx = b.x - cx, dy = b.y - cy;
  let dist = Math.hypot(dx,dy);
  if(dist > R) return null;

  let nx=0, ny=0;
  if(dist > 1e-6){
    nx = dx / dist; ny = dy / dist;
  }else{
    const prevX = b.px ?? b.x, prevY = b.py ?? b.y;
    const pcx = clamp(prevX, rx, rx+rw);
    const pcy = clamp(prevY, ry, ry+rh);
    const pdx = prevX - pcx, pdy = prevY - pcy;
    if(Math.abs(pdx) > Math.abs(pdy)){ nx = (prevX < rx) ? -1 : 1; ny = 0; }
    else { nx = 0; ny = (prevY < ry) ? -1 : 1; }
  }
  const push = (R - dist) + EPS;
  b.x += nx * push; b.y += ny * push;
  return {nx, ny};
}
function burst(x,y,c,n=18){
  const mult = 1 + Math.min(combo/8, 2.1);
  for(let i=0;i<Math.floor(n*mult);i++){
    const a=Math.random()*Math.PI*2, sp=1.0+Math.random()*3.2;
    particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:28,c,size:2+Math.random()*2});
  }
}
function meteorSparks(x,y){
  for(let i=0;i<6;i++){
    const a=Math.random()*Math.PI*2;
    const sp=0.9+Math.random()*2.4;
    particles.push({x,y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,life:20,c:"#ff9b50",size:2+Math.random()*2});
  }
}
function flash(intensity=1){ flashes.push({life:12,intensity}); }
function addShake(intensity=6, duration=180){
  const k = 1 + Math.min(combo/10, 1.9);
  shake.amp=Math.max(shake.amp,intensity*k);
  shake.t=Math.max(shake.t,duration);
}
function addHitstop(frames){
  hitstop = Math.max(hitstop, Math.min(frames, JUICE.hitstopMax));
}
function addCombo(n=1){
  combo += n;
  comboTimer = now() + JUICE.comboDecayMs;
  if(combo >= JUICE.rageThreshold){
    rageUntil = Math.max(rageUntil, now() + JUICE.rageMs);
  }
}
function decayCombo(){
  if(combo>0 && now()>comboTimer){
    combo = Math.max(0, combo-1);
    comboTimer = now() + 140;
  }
}

/* ===== Powers ===== */
function enlarge(){
  paddle.w=paddle.baseW*1.9;
  paddle.enlargeUntil=now()+5200;
  paddle.enlargePhase=1;
  flash(1.2); burst(paddle.x+paddle.w/2,paddle.y-8,COLOR_ENLARGE,26);
  addShake(5,140); addHitstop(1);
}
function multiball(b){
  const base=Math.atan2(b.vy,b.vx);
  [-26,0,26].forEach(d=>{
    const A=base+d*Math.PI/180;
    balls.push({
      x:b.x,y:b.y,r:10,
      vx:Math.cos(A)*b.speed,vy:Math.sin(A)*b.speed,
      speed:b.speed,launched:true,meteorUntil:0,
      px:b.x,py:b.y
    });
  });
  b.meteorUntil=now()+5200;
  b.speed=2.95;
  normalizeBall(b);
  flash(1.6); burst(b.x,b.y,"#ff8844",62);
  addShake(14,360); addHitstop(2);
}
function turretPower(){
  turretUntil = now() + JUICE.turretMs;
  flash(1.2); burst(paddle.x+paddle.w/2,paddle.y-16,COLOR_TURRET,30);
  addShake(10,240); addHitstop(1);
}

/* ===== Laser beam (sweeping) ===== */
function spawnLaserBeam(y){
  laserBeams.push({x:-40,y,life:32});
  flash(1.5); addShake(12,320); addHitstop(2);
}
function updateLaserBeams(){
  for(const lb of laserBeams){
    lb.x += JUICE.laserSweepSpeed;
    lb.life--;
    const band=20;
    for(const br of bricks){
      if(!br.alive) continue;
      if(br.type==="unbreakable") continue;
      const cy=br.y+br.h/2;
      if(Math.abs(cy-lb.y)<=band){
        const cx=br.x+br.w/2;
        if(cx <= lb.x){
          br.alive=false;
          burst(cx,cy,br.color,28);
          addCombo(1);
        }
      }
    }
  }
  laserBeams = laserBeams.filter(lb=>lb.life>0);
}

/* ===== Bomb (chain) ===== */
function bombExplode(x,y,radius=JUICE.bombRadius, chain=true){
  explosions.push({x,y,r:radius,life:18});
  flash(1.7); addShake(16,420); addHitstop(2);

  for(const br of bricks){
    if(!br.alive) continue;
    if(br.type==="unbreakable") continue;

    const cx=br.x+br.w/2, cy=br.y+br.h/2;
    const d=Math.hypot(cx-x, cy-y);
    if(d <= radius){
      const wasBomb = br.type==="bomb";
      br.alive=false;
      burst(cx,cy,br.color,36);
      addCombo(1);

      if(chain && wasBomb && d <= JUICE.bombChainRadius){
        setTimeout(()=>bombExplode(cx,cy,JUICE.bombRadius*0.92,false), 0);
      }
    }
  }
}

/* ===== Hit brick ===== */
function hitBrick(br, hitterBall){
  if(br.type==="unbreakable"){
    burst(br.x+br.w/2, br.y+br.h/2, "rgba(255,255,255,0.35)", 10);
    addShake(2,70);
    return false;
  }

  if(br.type==="laser"){
    br.alive=false;
    burst(br.x+br.w/2, br.y+br.h/2, COLOR_LASER, 36);
    addCombo(2);
    spawnLaserBeam(br.y+br.h/2);
    return true;
  }

  if(br.type==="bomb"){
    br.alive=false;
    burst(br.x+br.w/2, br.y+br.h/2, COLOR_BOMB, 44);
    addCombo(2);
    bombExplode(br.x+br.w/2, br.y+br.h/2, JUICE.bombRadius, true);
    return true;
  }

  if(br.hp && br.hp>1){
    br.hp--;
    br.color=HARD_COLOR_DMG;
    burst(br.x+br.w/2, br.y+br.h/2, br.color, 18);
    flash(1.05); addShake(5,150); addHitstop(1);
    addCombo(1);
    return false;
  }

  br.alive=false;
  burst(br.x+br.w/2, br.y+br.h/2, br.color, 26);
  flash(1.15); addShake(7,190); addHitstop(1);
  addCombo(1);

  if(br.type==="enlarge") enlarge();
  else if(br.type==="multiball" && hitterBall) multiball(hitterBall);
  else if(br.type==="turret") turretPower();

  return true;
}

/* ===== Level gen ===== */
function seededRng(seed){
  let s=seed>>>0;
  return ()=>{
    s^=s<<13; s>>>=0;
    s^=s>>17; s>>>=0;
    s^=s<<5;  s>>>=0;
    return (s>>>0)/4294967296;
  };
}
function ri(rng,a,b){ return a + ((b-a+1)*rng()|0); }

function generateGrid(lv){
  const rows=LEVEL_ROWS[lv], cols=COLS;
  const rng=seededRng(((Date.now()|0) ^ (lv*812381))>>>0);
  const g=Array.from({length:rows},()=>Array.from({length:cols},()=> "N"));

  const lanes = 2 + (lv>=3?1:0);
  for(let i=0;i<lanes;i++){
    const r=ri(rng,1,rows-2);
    for(let c=0;c<cols;c++) if(rng()<0.86) g[r][c]=".";
  }

  const blobs=2+(lv>=4?1:0);
  for(let i=0;i<blobs;i++){
    const br=ri(rng,1,rows-2), bc=ri(rng,1,cols-2), rad=ri(rng,1,2);
    for(let r=br-rad;r<=br+rad;r++){
      for(let c=bc-rad;c<=bc+rad;c++){
        if(r>=0&&r<rows&&c>=0&&c<cols && rng()<0.78) g[r][c]=".";
      }
    }
  }

  const wallCount = 2 + lv;
  for(let i=0;i<wallCount;i++){
    const r=ri(rng,1,rows-2), c=ri(rng,1,cols-2);
    if(g[r][c]==="N") g[r][c]="U";
  }

  const refillP = clamp(0.24 - lv*0.02, 0.12, 0.24);
  for(let r=0;r<rows;r++) for(let c=0;c<cols;c++){
    if(g[r][c]==="." && rng()<refillP) g[r][c]="N";
  }

  const hardCount = 6 + lv*2;
  for(let i=0;i<hardCount;i++){
    const r=ri(rng,0,rows-1), c=ri(rng,0,cols-1);
    if(g[r][c]==="N") g[r][c]="H";
  }

  function place(ch, count){
    let placed=0;
    for(let t=0;t<1600 && placed<count;t++){
      const r=ri(rng,0,rows-1), c=ri(rng,0,cols-1);
      if(g[r][c]==="N"){ g[r][c]=ch; placed++; }
    }
  }
  place("L", 3 + Math.floor(lv*1.0));
  place("B", 3 + Math.floor(lv*0.9));
  place("T", 2 + (lv>=3?1:0));
  place("M", 2 + (lv>=4?1:0));
  place("E", 2);

  return g.map(r=>r.join(""));
}

function makeBricks(lv){
  bricks=[];
  const rows=LEVEL_ROWS[lv];
  const mx=25,my=100,bw=(W-mx*2)/COLS,bh=40;
  const pal=["#ff4b4b","#ffa14b","#ffea4b","#ff6bd6","#ffd36b","#7cffc8"];
  const grid=generateGrid(lv);

  for(let r=0;r<rows;r++){
    for(let c=0;c<COLS;c++){
      const ch=grid[r][c]||".";
      if(ch===".") continue;

      let type="normal", color=pal[(r+c)%pal.length], hp=1;
      if(ch==="U"){ type="unbreakable"; color=COLOR_UNBREAK; hp=999; }
      else if(ch==="H"){ type="hard"; color=HARD_COLOR_FULL; hp=2; }
      else if(ch==="E"){ type="enlarge"; color=COLOR_ENLARGE; hp=1; }
      else if(ch==="M"){ type="multiball"; color=COLOR_MULTIBALL; hp=1; }
      else if(ch==="T"){ type="turret"; color=COLOR_TURRET; hp=1; }
      else if(ch==="L"){ type="laser"; color=COLOR_LASER; hp=1; }
      else if(ch==="B"){ type="bomb"; color=COLOR_BOMB; hp=1; }

      const ty=my+r*bh;
      const lift=710 + r*9 + (c%2)*16;

      bricks.push({
        x:mx+c*bw, y:ty-lift,
        ty, vy:6.9,
        w:bw-4, h:bh-4,
        type, color, hp,
        alive:true, falling:true
      });
    }
  }
}

/* ===== Ball init (NO AUTO LAUNCH) ===== */
function initBall(){
  balls=[{
    x:W/2,y:H-120,r:10,
    vx:0,vy:0,
    speed:JUICE.baseBallSpeed,
    launched:false,
    meteorUntil:0,
    px:W/2,py:H-120
  }];
}
function launchBallIfIdle(){
  const b=balls.find(v=>!v.launched);
  if(!b) return;
  b.launched=true;
  const a=(-62+Math.random()*30)*Math.PI/180;
  b.vx=Math.cos(a)*b.speed;
  b.vy=-Math.abs(Math.sin(a))*b.speed;
  normalizeBall(b);
}

/* ===== Restart ===== */
function restartBallsForNextLevel(){
  initBall();
  trail.length=0; particles.length=0;
  bullets.length=0; laserBeams.length=0; explosions.length=0;
  turretUntil=0;
  combo=0; comboTimer=0; rageUntil=0;
  hitstop=0;
}

/* ===== Turret fire (shotgun dual) ===== */
function fireTurretDualShotgun(){
  const t=now();
  if(t-lastShotMs < JUICE.turretCooldown) return;
  lastShotMs=t;

  const y=paddle.y - 22;
  const leftX  = paddle.x + 20;
  const rightX = paddle.x + paddle.w - 20;

  const spread = JUICE.turretSpreadDeg * Math.PI/180;
  const pellets = JUICE.turretPelletsPerSide;

  function shoot(originX){
    for(let i=0;i<pellets;i++){
      const k = (pellets===1)?0:(i-(pellets-1)/2);
      const ang = -Math.PI/2 + k*spread;
      bullets.push({
        x:originX, y, r:7,
        vx:Math.cos(ang)*2.2,
        vy:Math.sin(ang)*2.2 - 15
      });
    }
  }

  shoot(leftX);
  shoot(rightX);

  burst((leftX+rightX)/2, y, "#99d6ff", 16);
  addShake(3,80);
}

/* ===== Input ===== */
addEventListener("mousemove",e=>{
  const rect=cvs.getBoundingClientRect();
  const mx=e.clientY-rect.top;
  paddle.x=clamp(mx-paddle.w/2,0,W-paddle.w);
  for(const b of balls){
    if(!b.launched){
      b.x=paddle.x+paddle.w/2;
      b.y=paddle.y-b.r-2;
      b.px=b.x; b.py=b.y;
    }
  }
});
addEventListener("keydown",e=>{
  if(e.code==="Space"){
    if(state==="fail" || state==="win"){ resetGame(); return; }
    if(state!=="play") return;
    launchBallIfIdle(); // ✅ 只在你按 Space 才發射
  }
});

/* ===== Transition (drop) ===== */
function updateTransition(){
  let done=true;
  for(const br of bricks){
    if(!br.alive || !br.falling) continue;
    br.y+=br.vy; br.vy+=0.45;
    if(br.y>=br.ty){ br.y=br.ty; br.vy=0; br.falling=false; }
    else done=false;
  }
  if(done){
    state="play";
    // ✅ 這裡不自動發射了（你要手動按 Space）
  }
}
function hasBreakableAlive(){
  return bricks.some(b=>b.alive && b.type!=="unbreakable");
}

/* ===== Update ===== */
function update(){
  if(hitstop>0){ hitstop--; return; }
  decayCombo();

  const t=now();
  const rage = t < rageUntil;
  const rageK = rage ? JUICE.rageSpeedK : 1.0;

  if(state==="transition"){
    updateTransition();
  }else if(state==="play"){

    if(paddle.enlargeUntil && t>paddle.enlargeUntil){
      paddle.w=paddle.baseW; paddle.enlargeUntil=0; paddle.enlargePhase=0;
    }

    if(t < turretUntil){
      fireTurretDualShotgun();
    }

    updateLaserBeams();

    for(const ex of explosions) ex.life--;
    explosions = explosions.filter(ex=>ex.life>0);

    // bullets (no bounce)
    for(let i=bullets.length-1;i>=0;i--){
      const bl=bullets[i];
      bl.x += (bl.vx||0);
      bl.y += (bl.vy||-15);
      if(bl.y + bl.r < 0){ bullets.splice(i,1); continue; }

      let hit=false;
      for(const br of bricks){
        if(!br.alive) continue;
        const nx=clamp(bl.x,br.x,br.x+br.w);
        const ny=clamp(bl.y,br.y,br.y+br.h);
        const dx=bl.x-nx, dy=bl.y-ny;
        if(dx*dx+dy*dy <= bl.r*bl.r){
          const anyBall = balls.find(v=>v.launched) || balls[0];
          hitBrick(br, anyBall);
          addHitstop(1);
          hit=true; break;
        }
      }
      if(hit) bullets.splice(i,1);
    }

    // balls
    for(let i=balls.length-1;i>=0;i--){
      const b=balls[i];
      if(!b.launched) continue;

      b.px=b.x; b.py=b.y;

      const isMeteor = t<b.meteorUntil;
      const R = isMeteor ? 100 : b.r;

      b.x += b.vx * rageK;
      b.y += b.vy * rageK;

      trail.push({x:b.x,y:b.y,life:isMeteor?34:22,meteor:isMeteor});
      if(trail.length>520) trail.shift();
      if(isMeteor) meteorSparks(b.x - b.vx*0.8, b.y - b.vy*0.8);

      if(b.x-R<=0){ b.x=R+EPS; reflect(b,1,0); }
      if(b.x+R>=W){ b.x=W-R-EPS; reflect(b,-1,0); }
      if(b.y-R<=0){ b.y=R+EPS; reflect(b,0,1); }

      if(b.y+R>=paddle.y && b.x>=paddle.x && b.x<=paddle.x+paddle.w && b.vy>0){
        b.y=paddle.y-R-EPS;
        reflect(b,0,-1);
        addShake(isMeteor?10:6, isMeteor?240:160);
        addHitstop(1);
      }

      const pierce = rage;
      for(const br of bricks){
        if(!br.alive) continue;
        const hit = resolveCircleRect(b, R, br.x, br.y, br.w, br.h);
        if(hit){
          hitBrick(br, b);
          addHitstop(1);
          addShake(isMeteor?16:8, isMeteor?320:180);

          if(!pierce){
            reflect(b, hit.nx, hit.ny);
          }else{
            b.speed *= 1.01;
            normalizeBall(b);
          }
          break;
        }
      }

      if(b.y - R > H){
        balls.splice(i,1);
      }
    }

    if(!hasBreakableAlive()){
      if(level<MAX_LEVEL){
        level++;
        state="transition";
        makeBricks(level);
        restartBallsForNextLevel();
        flash(1.6); addShake(14,360); addHitstop(2);
      }else{
        state="win";
        flash(2.0); addShake(20,520); addHitstop(3);
      }
    }

    if(balls.length===0){
      state="fail";
      flash(1.8); addShake(18,520); addHitstop(3);
    }
  }

  for(const p of particles){ p.x+=p.vx; p.y+=p.vy; p.vy+=.14; p.life--; }
  particles=particles.filter(p=>p.life>0);

  for(const tr of trail) tr.life--;
  trail=trail.filter(tr=>tr.life>0);

  for(const f of flashes) f.life--;
  flashes=flashes.filter(f=>f.life>0);

  if(shake.t>0){
    shake.t-=16;
    shake.amp*=0.92;
    if(shake.t<=0){ shake.t=0; shake.amp=0; }
  }
}

/* ===== Draw ===== */
function draw(){
  const dx = (shake.t>0? (Math.random()*2-1)*shake.amp : 0);
  const dy = (shake.t>0? (Math.random()*2-1)*shake.amp : 0);

  ctx.save();
  ctx.translate(dx,dy);

  ctx.fillStyle="#0a0a1a"; ctx.fillRect(0,0,W,H);
  for(let y=0;y<H;y+=28){
    for(let x=0;x<W;x+=28){
      ctx.fillStyle=(x+y)%56===0?"#111a33":"#0d132a";
      ctx.fillRect(x,y,28,28);
    }
  }

  for(const ex of explosions){
    const a = ex.life/18;
    ctx.globalAlpha = 0.12 + 0.28*a;
    ctx.strokeStyle="rgba(255,255,255,1)";
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.arc(ex.x,ex.y, ex.r*(1.2-a*0.4),0,Math.PI*2);
    ctx.stroke();
    ctx.globalAlpha=1;
  }

  for(const lb of laserBeams){
    const a = lb.life/32;
    ctx.globalAlpha = 0.18 + 0.45*a;
    ctx.fillStyle="rgba(255,255,210,1)";
    ctx.fillRect(0, lb.y-7, lb.x, 14);
    ctx.globalAlpha = 0.10 + 0.25*a;
    ctx.fillStyle="rgba(255,255,255,1)";
    ctx.fillRect(0, lb.y-2, lb.x, 4);
    ctx.globalAlpha=1;
  }

  for(const br of bricks){
    if(!br.alive) continue;
    ctx.fillStyle=br.color; ctx.fillRect(br.x,br.y,br.w,br.h);

    if(br.type==="hard" && br.hp===1){
      ctx.fillStyle="rgba(0,0,0,0.25)";
      ctx.fillRect(br.x+6, br.y+8, br.w-12, 2);
      ctx.fillRect(br.x+12, br.y+18, br.w-24, 2);
    }
    if(br.type==="unbreakable"){
      ctx.fillStyle="rgba(255,255,255,0.08)";
      ctx.fillRect(br.x+6, br.y+6, 6, 6);
      ctx.fillRect(br.x+br.w-12, br.y+6, 6, 6);
      ctx.fillRect(br.x+6, br.y+br.h-12, 6, 6);
      ctx.fillRect(br.x+br.w-12, br.y+br.h-12, 6, 6);
    }
    if(br.type==="laser"){
      ctx.fillStyle="rgba(255,255,255,0.6)";
      ctx.fillRect(br.x, br.y+br.h*0.35, br.w, 3);
    }
    if(br.type==="bomb"){
      ctx.fillStyle="rgba(255,255,255,0.38)";
      ctx.fillRect(br.x+br.w*0.34, br.y+br.h*0.28, br.w*0.32, br.h*0.32);
    }
    ctx.fillStyle="#000"; ctx.fillRect(br.x,br.y+br.h-3,br.w,3);
  }

  if(paddle.enlargePhase){
    const k=(Math.sin(now()/90)*0.5+0.5);
    ctx.shadowBlur=26+12*k;
    ctx.shadowColor=COLOR_ENLARGE;
    ctx.fillStyle=`rgba(57,224,113,${0.45+0.35*k})`;
  }else ctx.fillStyle="#d8d8d8";
  ctx.fillRect(paddle.x,paddle.y,paddle.w,paddle.h);
  ctx.shadowBlur=0;

  const firing = now() < turretUntil;
  if(firing){
    const y = paddle.y - 18;
    ctx.fillStyle="rgba(255,255,255,0.92)";
    ctx.fillRect(paddle.x-12, y, 22, 14);
    ctx.fillRect(paddle.x+paddle.w-10, y, 22, 14);
    ctx.fillStyle="rgba(0,0,0,0.75)";
    ctx.fillRect(paddle.x-12, y+11, 22, 3);
    ctx.fillRect(paddle.x+paddle.w-10, y+11, 22, 3);
  }

  for(const tr of trail){
    const a = tr.life/(tr.meteor?34:22);
    ctx.globalAlpha = a*0.65;
    ctx.fillStyle = tr.meteor ? "#ff9b50" : "#99d6ff";
    ctx.beginPath();
    ctx.arc(tr.x,tr.y, tr.meteor ? (10 + 8*a) : (3 + 3*a), 0, Math.PI*2);
    ctx.fill();
  }
  ctx.globalAlpha=1;

  for(const b of balls){
    const isMeteor = now()<b.meteorUntil;
    if(isMeteor){
      const R=100;
      const g=ctx.createRadialGradient(b.x,b.y,R*0.2,b.x,b.y,R);
      g.addColorStop(0,"rgba(255,235,200,0.92)");
      g.addColorStop(0.6,"rgba(255,155,80,0.58)");
      g.addColorStop(1,"rgba(255,120,40,0.26)");
      ctx.fillStyle=g;
      ctx.beginPath(); ctx.arc(b.x,b.y,R,0,Math.PI*2); ctx.fill();
      ctx.shadowBlur=22; ctx.shadowColor="#ffb066";
      ctx.strokeStyle="rgba(255,200,120,0.88)"; ctx.lineWidth=2;
      ctx.beginPath(); ctx.arc(b.x,b.y,R-2,0,Math.PI*2); ctx.stroke();
      ctx.shadowBlur=0;
    }else{
      ctx.fillStyle="#fff";
      ctx.beginPath(); ctx.arc(b.x,b.y,b.r,0,Math.PI*2); ctx.fill();
    }
  }

  ctx.fillStyle="#99d6ff";
  for(const bl of bullets){
    ctx.beginPath(); ctx.arc(bl.x,bl.y,bl.r,0,Math.PI*2); ctx.fill();
  }

  for(const p of particles){
    ctx.globalAlpha = Math.max(p.life/28,0);
    ctx.fillStyle=p.c;
    ctx.fillRect(p.x,p.y,p.size,p.size);
  }
  ctx.globalAlpha=1;

  ctx.fillStyle="rgba(255,255,255,0.90)";
  ctx.font="bold 22px monospace";
  ctx.textAlign="left";
  ctx.fillText(`LEVEL ${level}/${MAX_LEVEL}`, 16, 34);

  if(combo>0){
    const rage = now()<rageUntil;
    ctx.textAlign="right";
    ctx.fillStyle = rage ? "rgba(255,210,120,0.95)" : "rgba(255,255,255,0.85)";
    ctx.fillText(`COMBO x${combo}`, W-16, 34);
    if(rage){
      ctx.font="bold 14px monospace";
      ctx.fillText(`RAGE = PIERCE`, W-16, 56);
    }
  }

  if(state==="transition"){
    ctx.textAlign="center";
    ctx.font="bold 44px monospace";
    ctx.fillStyle="#fff";
    ctx.fillText(`LEVEL ${level}`, W/2, H/2);
    ctx.font="bold 18px monospace";
    ctx.fillText("Press Space to Launch", W/2, H/2+46);
  }
  if(state==="fail"){
    ctx.textAlign="center";
    ctx.font="bold 56px monospace";
    ctx.fillStyle="#fff";
    ctx.fillText("GAME OVER", W/2, H/2);
    ctx.font="bold 20px monospace";
    ctx.fillText("Press Space to Restart", W/2, H/2+52);
  }
  if(state==="win"){
    ctx.textAlign="center";
    ctx.font="bold 56px monospace";
    ctx.fillStyle="#fff";
    ctx.fillText("YOU WIN", W/2, H/2);
    ctx.font="bold 20px monospace";
    ctx.fillText("Press Space to Restart", W/2, H/2+52);
  }

  for(const f of flashes){
    ctx.globalAlpha = (f.life/12)*0.35*(f.intensity||1);
    ctx.fillStyle="#fff";
    ctx.fillRect(0,0,W,H);
  }
  ctx.globalAlpha=1;

  ctx.globalAlpha=0.15; ctx.fillStyle="#000";
  for(let y=0;y<H;y+=3) ctx.fillRect(0,y,W,1);
  ctx.globalAlpha=1;
  const vign=ctx.createRadialGradient(W/2,H/2,0,W/2,H/2,W*0.8);
  vign.addColorStop(0,"rgba(0,0,0,0)");
  vign.addColorStop(1,"rgba(0,0,0,0.35)");
  ctx.fillStyle=vign; ctx.fillRect(0,0,W,H);

  ctx.restore();
}

/* ===== Reset ===== */
function resetGame(){
  level=1; state="transition";
  particles=[]; trail=[]; flashes=[];
  bullets=[]; laserBeams=[]; explosions=[];
  turretUntil=0;
  combo=0; comboTimer=0; rageUntil=0;
  hitstop=0;
  paddle.w=paddle.baseW; paddle.enlargeUntil=0; paddle.enlargePhase=0;
  makeBricks(1);
  initBall();
  flash(1.4); addShake(14,360); addHitstop(2);
}

/* ===== Start ===== */
makeBricks(1);
initBall();

/* ===== loop ===== */
(function loop(){ update(); draw(); requestAnimationFrame(loop); })();
})();
</script>
</body>
</html>
